《函数式语言程序设计》大作业
计科30 潘薪宇 郑弘宇
软件31 罗剑桥
一、得分项实现情况
1.功能项目：独立主程序、REPL、解释器、文法解析、Pretty-printer、错误处理、代码测试、代码风格
2.语言特性：逻辑表达式、浮点算数表达式、字符串与列表、While语言、数组、一阶函数、文法作用域、高阶函数

二、功能项目部分实现简述
1.独立主程序：在Main.hs中实现，编译后生成可执行文件ki，用法与文档中所述一致。使用了System.Environment的getArgs函数进行参数捕获。注意我们的主程序会以main函数为入口，但允许在main函数之前执行位于一阶函数之外的全局变量的复制
2.REPL：在REPL.hs中实现。我们在evaluation过程中使用了MonadState，所以REPL相比之下只需将之前的State记录下来并不断对用户新输入的指令进行处理。对于功能项目中的解释器，我们在REPL里提供了":p"指令，接受一个表达式作为参数进行evaluation。
3.解释器：请参见REPL的说明。
3.文法解析：前端文法解析基于Parsec库实现。我们提供的parser对各个token之间的空白字符不敏感，同时支持C语言风格的单行与多行注释。因为Parsec是一个比较成熟并被广泛使用的框架，这里就只简单提实现时需要注意的两点：一是在匹配时可能需要backtrack的位置要使用try避免消耗输入；另外在匹配时需要保证消耗完所有输入，避免程序段中间出现错误时直接截断而不输出正确的报错信息。我们的AST定义如下所示。
data ProgDecl = Program Stmt
data Stmt = StmtList [Stmt]
          | Assign String Expr
          | Skip          
          | If Expr Stmt Stmt 
          | While Expr Stmt
          | ArrayDef String Expr
          | ArrayAssign String Expr Expr
          | Return Expr
data Expr = BoolLit Bool 
          | IntLit Integer
          | DoubleLit Double
          | CharLit Char
          | NilList
          | Var String
          | ArrayEntry String Expr
          | ABinary ABinOp Expr Expr
          | Not Expr
          | BBinary BBinOp Expr Expr
          | RBinary RBinOp Expr Expr
          | Pair Expr Expr
          | PairFst Expr
          | PairSnd Expr
          | Call Expr [Expr]
          | Function [String] Stmt
          | Let String Expr Expr
data BBinOp = And | Or deriving
data RBinOp = EQ | GE | LE | GT | LT
data ABinOp = Add | Subtract | Multiply | Divide


4.Pretty-printer：
在Spec.hs中实现了Pretty-printer。将抽象数据类型Stmt和ProgDecl声明为Show类型类的实例，定义了不同类型语句的显示方式，并根据程序结构层次加入相应数目的空格缩进。

5.错误处理：
我们给出的错误信息包括静态分析时借助Parsec库给出的文法错误，以及解释运行时给出的运行时错误。运行时错误大概包括以下几个方面：类型不匹配错误，如If和While语句的条件变量必须是Bool类型，四则运算的运算数必须是Integer类型或Double类型等；未定义错误，例如引用不在定义域里的变量或者未声明的函数；数组相关错误，如访问越界和引用未初始化数组元素；函数应用类错误，如函数应用时参数个数不匹配或者未有正确定义的返回值。（注意由于我们实现了高阶函数，我们将partial evaluation自然延拓到一阶函数上）每一类运行时错误都会给出相关信息，方便改正。

6.代码测试：
在Test.hs中进行了一系列的用例测试。我们对于不同类型的表达式、不同类型的语句、一阶函数及高阶函数等功能都进行了测试。test_exprs部分测试各种表达式，test_stmts部分测试各种语句和函数。对于逻辑表达式和算术表达式，测试了各种情况下的结果，包括浮点数运算溢出等。对于While语言和函数，抽样测试了if语句、while语句、函数引用等样例。除了测试正常程序的执行结果是否正确，还对如类型不匹配、数组越界、未知变量等异常情况进行了测试。程序能够返回预期的错误信息。运行"ki -test"即可查看测试情况。

7.代码风格：
整个大作业采用了cabal/stack进行项目管理，前端使用了Parsec库，后端使用了StateMonad以及Data.Map,使用比较精简的代码实现了全部语言特性。src目录下有Spec,WhileParser,Process,REPL，Main五个文件，分别对应Lexer和AST的specification，前端文法解析，evaluation，REPL以及解释器主程序等功能。Parser以及Evaluator都采用自顶向下模块化的设计方法，虽然我们没有特别为不同特性集划分module，但整体上还是比较容易扩展。

四、语言特性部分实现简述
1.逻辑表达式：这部分实现起来比较简单。在TypeCheck时我们要求逻辑表达式的变量必须为Bool类型，不会将非0的数值类型转换为True。
2.浮点算术表达式：我们在文档要求的基础上，实现了Integer类型和Double类型。当Integer类型值和Double类型值作用时，会先提升至Double类型。我们另外还支持负数常量，但是不支持科学计数法。在TypeCheck时我们要求算术表达式的变量必须为这两种类型，不会将True转换为1。
3.字符串和列表：在用列表实现字符串时，我们采用与Haskell语言类似的风格，如"ABC"对应的AST为Pair 'A' (Pair 'B' (Pair 'C' NilList))。我们允许Pair的两个成员具有不同的类型，允许用户利用Pair构造的列表中存在多个NilList元素。
4.While语言：While语言引进了控制流和变量定义。控制流方面按照定义实现即可。变量定义的引入使得我们需要维护内存的状态，我们用StateMonad来实现这一特性。关于变量作用域的讨论请参见后续文法作用域部分。
5.数组：我们的数组采用一个(Integer, Map Integer Variable)的二元组来描述。除实现文档要求的功能外，我们的数组还具有以下特性：数组的identifier可以被用作其他变量，数组元素或者函数的参数赋值，此时我们采用按值传递而非按引用传递，即我们会拷贝构造出一个相等的数组进行赋值（使用Map.strict 避免Haskell的惰性求值特性推迟复制变量）；虽然数组长度是固定的，但只有当某个entry被使用时，才会为其开辟内存，实现了Lazy Storage。
6.一阶函数：此处讨论的是限制在命令式语言时的情形，拓展了高阶函数之后的情形请参见高阶函数一节。设计的核心在于确定内存空间的状态如何表示。按文档所述程序被定义为函数的集合，函数之间互不嵌套，一个时刻只会有一个函数体的变量表可用，所以我们可以用一个VarMap表示当前函数体内的变量表。另外所有一阶函数的名字应全局可见，且在执行程序时需要获得名为main的函数，我们还需要一个全局的FuncMap。所以到一阶函数为止我们可以用一个二元组(VarMap, FuncMap)来表示当前解释器的状态。一阶函数的return方法必须能够跳出当前函数的控制流，并把这个值返回给调用者。由于return一词是保留字，我们有这样一个小Trick：在VarMap[“return”]内保存内存函数的返回值。在控制流内，如果执行了某一操作后VarMap[“return”]存在，直接跳出当前控制流。
7.文法作用域：这里讨论在一阶函数的基础上增加let binding的特性。注意let可以在一个函数内嵌套，还可以重名。但由let声明的变量是不变的，因为let只出现在expression中，且在同一expr计算完毕前let声明的变量已经过期，没有修改的可能。因此我们现在使用一个三元组(VarMap, VarStack, FuncMap)来表示解释器状态，其中新加入的VarStack为当前嵌套let语句的变量栈。开启Let语句时，在栈顶放上绑定的变量。离开Let语句时弹出。进入新函数时，暂存之前的状态，然后清空VarStack,VarMap置为该函数的参数集合。查询变量优先在VarStack上从顶向下查询，其次查VarMap。更新变量时，由于let声明的变量永远不变，只要在VarMap上操作就行。（注意：为了实现高阶函数，我们放弃了这一解释器状态的实现，也导致了最终解释器并不是严格地执行文法作用域的规则。请看下段）
8.高阶函数：文档所述的lambda表达式只允许绑定一个变量，而用define定义的一阶函数则可以接受多个参数。为了统一处理两者，我们对lambda表达式的语法稍作扩展，增加一个 (lambda (var ...) expr)。一阶函数（必须）接受若干个参数才能运行，因此我们也将对应语法扩充至(expr expr … expr)，表示将第一个expr以后的所有表达式绑定到第一个expr(在一阶函数的情形内，这一定是一个函数名）。
接下来我们把所有函数都视为一种特殊的变量，特别地将一阶函数(define (name vars) stmt)定义为name = lambda vars stmt（因此用define定义的一阶函数是可以做部分赋值的，和lambda声明的没有分别）。我们用一个三元组(Variables, KnownValues, Statement)表示一个partial function的状态，Variable和Statement从原函数定义中获得，KnownValues是已经知道的值。绑定元素就是将计算结果附加到KnownValues上，同时由于现在的解释器对多态支持不好，我们认为当一个部分函数的所有变量都有值后就立即展开并计算。然而对于无参数的一阶函数，这样的处理方式会导致函数体函数体会马上被计算。注意到Lambda表达式至少需要一个变量，我们给原来无参数的一阶函数函数增加一个dummy变量，这个变量除了阻止函数自动展开没有其他作用。
由于define都是set语句，我们现在也允许程序主体出现其他statement；运行一个程序相当于先运行程序中的statement，再返回无参数调用main的结果。为了尽量和一阶函数的情形相匹配，我们在parse时限制主程序里仅允许set与define语句出现。
8‘. 动态作用域：由于现在函数体可以通过匿名表达式嵌套，静态作用域需要维护每个函数体之间的包含关系，因此我们认为此时实现一个静态作用域过于复杂，但一个运行时决定的动态作用域则比较方便。解释器的状态现在为[VarMap]，每个元素都是调用栈某一层的符号表。Let语句也视为一次调用，占用一层符号表。由于函数均是变量，先前用于维护函数名字的变量表现在是解释器状态的最低一层（与其他可能的全局变量一起）。
对于变量的查找与修改，我们将查找默认为在全符号表栈上查最近变量，但修改可以仅在最近符号表上修改，或先查到栈上变量，再进行修改，如果栈上没有这一名字的变量，则在最近的符号表上创建变量。由于语言本身特性，我们无法区分“定义一个新变量”以及“修改一个已有变量”的操作，因此全局修改可能会导致意想不到的后果（尤其是在比较复杂的递归程序内）。尽管我们实现了这一功能，最后上交的版本内并没有实现，而是使用了全局查找与本地修改的结合。可以在Process.hs的第31-35行间注释特定的语句来切换这两个功能。
另外注意引入动态作用域会使得程序行为和文法作用域的程序行为不完全吻合。对此，我们注意到，如果只考虑作业要求中的一阶函数部分或只考虑作业要求中的高阶函数部分，动态作用域严格强于静态作用域；即在文法作用域规则下能够查询到的变量，在动态作用域下一定可以查询到，但反之则不然，因此我们认为实现动态作用域属于“有益的扩展”。当然，在我们最终上交的版本内，这两种规则会导致一些不同，但这是因为我们实现了超出作业要求的内容所导致的，因此我们认为我们自行处理了这一部分的情况。